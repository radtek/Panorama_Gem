<% @update_area = get_unique_area_id %>

<%=

  def link_monitor(rec)
    my_ajax_post_link(fn(rec.sql_exec_id),
                      {
                        :controller   => :dba_sga,
                        :action       => :start_sql_monitor_in_new_window,
                        :instance     => rec.inst_id,
                        :sid          => rec.sid,
                        :serialno     => rec['session_serial#'],
                        :sql_id       => rec.sql_id,
                        :sql_exec_id  => rec.sql_exec_id,
                        :update_area  => @update_area
                      },
                      :title  => 'Generate SQL-Monitor. See hints of button \'SQL Monitor\' for further preconditions'
                      )
  end

  column_options = [
      {:caption=>'SQL exec ID',       :data=>proc{|rec| link_monitor(rec)},                     :title=>"Execution identifier. Together, the three columns SQL_ID, SQL_EXEC_START, and SQL_EXEC_ID represent the execution key. The execution key is used to uniquely identify one execution of the SQL statement.", :align=>:right},
      {:caption=>'Instance',          :data=>proc{|rec| rec.inst_id},                           :title=>"Instance number"},
      {:caption=>'Status',            :data=>proc{|rec| rec.status},                            :title=>"SQL execution status:\nEXECUTING - SQL statement is still executing\nDONE (ERROR) - Execution terminated with an error\nDONE (FIRST N ROWS) - Execution terminated by the application before all rows were fetched\nDONE (ALL ROWS) - Execution terminated and all rows were fetched\nDONE - Execution terminated (parallel execution)"},
      {:caption=>'First refresh time',:data=>proc{|rec| localeDateTime(rec.first_refresh_time)},:title=>"Time when monitoring of the SQL statement started, generally a few seconds after execution start time"},
      {:caption=>'Last refresh time', :data=>proc{|rec| localeDateTime(rec.last_refresh_time)}, :title=>"Time when statistics in V$SQL_MONITOR were last updated for the SQL statement. Statistics are generally refreshed every second when the statement executes."},
      {:caption=>'Refresh count',     :data=>proc{|rec| fn(rec.refresh_count)},                 :title=>"Number of times V$SQL_MONITOR statistics have been refreshed (generally once every second when the SQL statement executes)", :align=>:right},
      {:caption=>'SID',               :data=>proc{|rec| link_session_details(@update_area, rec.inst_id, rec.sid, rec['session_serial#']) }, :title=>"Session identifier + serial number executing (or having executed) the SQL statement being monitored"},
      {:caption=>'SQL-ID',            :data=>proc{|rec| link_sql_id(@update_area, rec.inst_id, rec.sql_id, nil, nil, nil, rec.hex_sql_child_address)},  :title=>"SQL identifier of the statement being monitored"},
      {:caption=>'SQL exec start',    :data=>proc{|rec| localeDateTime(rec.sql_exec_start)},    :title=>"Time when the execution started"},
      {:caption=>'Plan hash value',   :data=>proc{|rec| fn(rec.sql_plan_hash_value)},           :title=>"SQL Plan hash value", :align=>:right},
      {:caption=>'Elapsed time',      :data=>proc{|rec| fn(rec.elapsed_time)},                  :title=>"Elapsed time (in microseconds); updated as the statement executes", :align=>:right},
      {:caption=>'CPU time',          :data=>proc{|rec| fn(rec.cpu_time)},                      :title=>"CPU time (in microseconds); updated as the statement executes", :align=>:right},
      {:caption=>'Application wait time',   :data=>proc{|rec| fn(rec.application_wait_time)},   :title=>"Application wait time (in microseconds); updated as the statement executes", :align=>:right},
      {:caption=>'Concurrency wait time',   :data=>proc{|rec| fn(rec.concurrency_wait_time)},   :title=>"Concurrency wait time (in microseconds); updated as the statement executes", :align=>:right},
      {:caption=>'Cluster wait time', :data=>proc{|rec| fn(rec.cluster_wait_time)},             :title=>"Cluster wait time (in microseconds); updated as the statement executes", :align=>:right},
      {:caption=>'User I/O wait time',:data=>proc{|rec| fn(rec.user_io_wait_time)},             :title=>"User I/O Wait Time (in microseconds); updated as the statement executes", :align=>:right},
      {:caption=>'PL/SQL exec time',  :data=>proc{|rec| fn(rec.plsql_exec_time)},               :title=>"PL/SQL execution time (in microseconds); updated as the statement executes", :align=>:right},
      {:caption=>'Java exec time',    :data=>proc{|rec| fn(rec.java_exec_time)},                :title=>"Java execution time (in microseconds); updated as the statement executes", :align=>:right},
      {:caption=>'Fetches',           :data=>proc{|rec| fn(rec.fetches)},                       :title=>"Number of fetches associated with the SQL statement; updated as the statement executes", :align=>:right},
      {:caption=>'Buffer gets',       :data=>proc{|rec| fn(rec.buffer_gets)},                   :title=>"Number of buffer get operations; updated as the statement executes", :align=>:right},
      {:caption=>'Disk reads',        :data=>proc{|rec| fn(rec.disk_reads)},                    :title=>"Number of disk reads; updated as the statement executes", :align=>:right},
      {:caption=>'Direct writes',     :data=>proc{|rec| fn(rec.direct_writes)},                 :title=>"Number of direct writes; updated as the statement executes", :align=>:right},
  ]



  caption = "Recorded execution deatils from gv$SQL_monitor for"
  caption << " Instance=#{@instance},"                if @instance
  caption << " SQL-ID='#{@sql_id}',"                  if @sql_id
  caption << " Plan-Hash-Value=#{@plan_hash_value},"  if @plan_hash_value
  caption << " SID=#{@sid},"                          if @sid
  caption << " Serial#=#{@serialno},"                 if @serialno

  caption = caption.slice(0, caption.length-1)      # letztes nachfolgendes Komma entfernen

  gen_slickgrid(@sql_monitor_records, column_options, {
      :max_height => 450,
      :caption    => caption
  })
%>
<div id="<%= @update_area %>"></div>


